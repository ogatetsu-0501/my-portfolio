# カードゲーム用デスクトップシミュレーター（共同開発）

友人がカードゲームを始めたタイミングで  
「プロキシ（印刷カード）を作る手間を減らすためのシミュレーターを作りたい。手伝ってくれない？」  
という相談を受け、分担して開発したプロジェクトです。

友人は優秀なWebエンジニアで、  
**デッキ作成用のUI / Webページ / カードデータベース** を担当。  
私は **抽象的なルールをロジックに落とし込むこと**が得意だったため、  
Pythonで **PC前提・exe配布を想定したゲームシミュレーター部分**を担当しました。

友人側のアプリで作成されたデッキデータ（JSON）を読み取り、  
その内容をもとにゲーム内でデッキを構築します。  
カードの状態処理や進行ロジックは、  
**プレイヤーである友人への聞き取り**と**公式ルールブックの解釈**をもとに実装しました。

過去に別の個人制作カードゲームシミュレーターで遊んだ経験があり、  
「どういう状態管理・操作感にすれば検証しやすいか」という実装イメージは比較的湧きやすかったです。

---

## 全体構成

- **Web側（友人担当）**
  - デッキ作成UI
  - Webページ
  - カードデータベース

- **デスクトップ側（自分担当 / Python）**
  - デッキJSONの読み込み・構築
  - ターン進行・ドロー・コスト支払い・配置・移動などの基本進行処理
  - サーチ / 公開 / 控室確認など、紙で煩雑な操作のUI化
  - 統計機能（成功確率・必要枚数の検討支援）
  - exe化・配布・更新処理

Web側とデスクトップ側は  
**「デッキJSONを受け取る」一点で疎結合**にし、  
それぞれ独立して改善できる構成にしています。

---

## 主な機能（実装内容ベース）

### ゲーム進行の自動化（紙で面倒な部分を優先）

- **マリガン処理**
  - 交換対象カードを選択して戻し、山札をシャッフル
  - マリガン前の状態に戻すリセット処理も用意

- **フェイズ進行**
  - アクティブフェイズでカード状態（横→縦）を復帰
  - エナジーフェイズでエナジーデッキから補充（最大枠制御）
  - ドローフェイズで山札から手札へ自動追加

- **コスト支払い処理**
  - カードに貯めたエナジーの管理と返却処理
  - コスト不足時は「0コストで強行するか？」の確認モーダルを表示し、
    プレイヤー判断で続行・キャンセル可能

- **バトンタッチ（入れ替え）処理**
  - 旧カードを控室へ移動
  - 旧カードが保持していたエナジーを自動返却
  - 一連の操作をまとめて履歴に記録し、Undo可能に

---

### カード効果以外の「検証の邪魔」を減らすUI

- **サーチ機能**
  - 名前、種別、ユニット、コスト条件、ハート条件、ブレード条件など
    複数条件を組み合わせた検索UI
  - プルダウン・スクロール対応で大量カードでも扱いやすく設計

- **山札上からの公開（めくり）**
  - 指定枚数を公開し、モーダルで一覧表示
  - ページ切り替え・モーダル移動に対応

- **控室確認**
  - 控室カードをモーダル表示
  - 公開モーダルと同様にページング・移動可能

- **盤面操作ミスを防ぐ仕組み**
  - カードを近いスロットへ吸着させるスナップ処理
  - 手札はx座標基準で自動整列・差し込み

---

## 実装の要点

### 状態の一元管理

山札・手札・場といったカード状態だけでなく、  
検索モーダルの入力中状態や、公開モーダルのページ位置なども含めて  
**すべてを `GameState` データクラスに集約**しています。

- 状態は `GameState` が唯一の正とし、
- イベント処理は `state` を直接更新、
- 描画は常に `state` を参照

という流れに統一しました。

これにより、  
UIが増えても「どこかの変数が壊れて進行不能になる」事故を避けやすく、  
拡張時も影響範囲を限定できます。

---

### バトンタッチ処理のまとめ実装

バトンタッチはプレイ頻度が高く、  
紙ではミスや手戻りが起きやすい操作のため、  
以下を**一連の処理としてまとめて実装**しました。

- 新カードの配置
- 旧カードの控室移動
- エナジー返却
- Undo用の操作履歴登録

これにより、  
「操作を間違えたらすぐ戻せる」検証向けの操作感を実現しています。

---

## 苦戦した点・学び

### 統計機能の並列実行

ゲーム本体はPygameのメインループで動作しますが、  
統計情報は別ウィンドウで常時表示したかったため、Tkinterを使用しました。

同一スレッドで両方のイベントループを回すとフリーズしやすく、  
最終的に **統計ウィンドウは別スレッドで起動**する構成にしています。

これにより、  
ゲーム操作を止めずに確率や必要枚数を確認しながら検証できるようになりました。

---

### 自動アップデートとウイルス誤検知

exe配布を前提に、自動アップデート機構も実装しましたが、  
外部ダウンロード・ファイル置換を伴う挙動のため、  
**ウイルス対策ソフトに誤検知される問題**が発生しました。

調査の結果、コード内容というより  
**「自己更新を行うプログラムの挙動そのもの」**が
検知条件に引っかかりやすいことが原因だと分かりました。

この経験から、

- 自動更新の方式設計
- 配布物としての安全性・説明責任
- 更新処理の分離やセミオート化

といった点まで含めて設計する重要性を学びました。

---

## 成果・反応

- 友人とその周囲がこのツールを使ってデッキ検証を行い、
  全国大会を目指して調整を続けていると聞いています。
- 紙のプロキシよりも速く試行でき、
  統計機能によって**検証効率と判断材料が大きく向上**しました。

---

## 使用技術

- Python 3
- Pygame（メインUI）
- Tkinter（統計ウィンドウ）
- PyInstaller（exe化）
- JSON（デッキデータ連携）
- GitHub API + AES復号（カードデータ更新）
