# ゲーム内マーケット分析・可視化ツール（個人開発）

オンラインゲームの公式アバターオークション（マーケット）情報を収集・分析し、  
価格や性能を比較しやすく可視化するために開発した個人プロジェクトです。

---

## 概要

公式マーケットは検索・比較機能がシンプルで、

- 過去の価格推移が分からない  
- 性能と価格の妥当性を比較しづらい  
- 自分の所持アイテムとの差分が把握しにくい  

といった課題がありました。

友人とゲームで遊んでいる中で、  
「今これを買うと、いくらでステータスがいくつ上がるのか」  
「相場はどのくらいなのか」  
が公式画面からは判断できず、購入判断を支援するために開発しました。

本ツールでは、取引データを自動収集・集計し、  
**フィルタ・ソート中心の比較UI**と**相場の履歴可視化**を提供しています。

---

## 全体構成

- **バックエンド**：取引データの定期取得・集計・履歴化  
- **フロントエンド**：検索・比較・所持差分計算・グラフ表示  

収集・集計処理と表示ロジックを分離し、  
フロント側は保存済みデータを読むだけで軽量に動作する構成としています。

---

## 主な機能

### データ収集・分析（バックエンド）
- マーケット取引データの定期自動取得  
- 価格履歴の蓄積・圧縮  
- 最安値マップの生成（種類・上昇値・部位別）  
- 独自指標によるコストパフォーマンス算出  

### 可視化・比較（フロントエンド）
- 条件フィルタ・並び替え（ソート）  
- 所持アイテムとの差分自動計算  
- 価格推移チャート表示  
- ユーザー要望による機能拡張（所持登録拡張・購入後登録・相場チャート）

---

## 使用技術

### バックエンド
- Node.js  
- クラウド関数（HTTPトリガー）  
- GitHub REST API  
- p-limit（並列数制御）  
- fetch  

### フロントエンド
- HTML / JavaScript  
- localStorage  
- Chart.js  
- DOM操作  

---

## 実装の要点（実装内容ベース）

### バックエンド：大量取得と安定性を重視した設計

取引データは件数が多くなるため、  
**並列数を制限しながら段階的に取得**する構成としました。

- 一覧取得 → 詳細取得 → 正規化 → 集計 → 保存  
という処理パイプラインを分離し、  
個別の取得失敗が全体を止めないようにしています。

価格履歴は単純な時系列追加ではなく、

- 近接データの圧縮  
- 更新点を判別できるフラグ付与  
- 古い履歴の整理  

を行い、**グラフ用途として意味を保ちながらサイズを抑制**しています。

---

### フロントエンド：比較と判断に最短で到達するUI

UIは「情報を見る」よりも  
**購入判断に必要な結論へ最短で到達できること**を重視しました。

- 性別・部位・種類・上昇値条件によるフィルタ  
- ヘッダクリックによる昇順・降順ソート  
- 所持アイテムの最大値との差分を自動計算  

特に、所持アイテムは  
「同一条件では最大値のみを保持する」ルールとし、  
常に“今どれだけ伸ばせるか”が分かる状態を維持しています。

---

### ユーザー要望による機能拡張

実際に使ったユーザーからの要望を受け、

- 所持アイテム登録機能の拡張  
- 購入後にワンクリックで所持登録できる導線  
- 相場の推移を確認できるチャート表示  

を追加し、  
**使われながら成長するツール**として改善を重ねました。

---

## （当時の判断）GitHubを“データストア”として使った理由と結果

当初は、  
サーバー側にデータを保持してサイトを提供すると、  
アクセス増加に応じてランニングコストが膨らみ、  
**想定外に高額化するリスク**があると考えました。

個人開発として上振れリスクを避けるため、  
集計結果（複数のJSON）を **GitHubリポジトリへ更新する方式**を選択しました。

実装上は、

- 既存ファイルを取得して差分を確認  
- 変更があるファイルのみを対象に  
- 複数ファイルを1コミットにまとめて反映  

することで、  
毎回全更新にならないよう工夫していました。

しかし結果としては、  
更新処理（push相当）が別リージョンへのアクセスとなるなどの要因で  
**想定よりもコストが発生**し、  
コスト回避のための選択が別のコストを生む形になりました。

この点は明確に失敗であり、  
今なら最初から **Firestore等のデータベースを前提に設計**します。

---

## 成果・反応

- 相場と性能差分が即座に把握でき、購入判断が早くなった  
- フィルタ・ソート中心のUIにより比較コストを削減  
- ユーザー要望を取り入れながら継続的に改善  

---

## 想定外だった点・学び

コスト上振れリスクを避けるために選んだ構成が、  
別のコスト要因（更新経路・リージョン差）によって成立しづらくなることを経験しました。

この経験から、

- 参照コスト  
- 更新コスト  
- データ配置（リージョン）  

を分けて考え、  
**運用まで含めたアーキテクチャ設計が重要**であることを学びました。

今なら、  
更新頻度と参照パターンを前提に  
データベース＋静的配信の形で組み直します。
